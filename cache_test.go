package main

import (
	"fmt"
	"sync"
	"testing"
	"time"
)

type Updater struct {
	mutex    sync.Mutex
	WaitTime time.Duration
	Called   map[string]int
}

func (u *Updater) Update(key string) (interface{}, error) {
	time.Sleep(u.WaitTime)

	u.mutex.Lock()
	defer u.mutex.Unlock()
	u.Called[key] += 1

	if len(key) >= 5 && key[:5] == "ERROR" {
		return nil, fmt.Errorf("Update: cannot retrieve a value for key = %s", key)
	}

	return fmt.Sprintf("value generated by updater(%s)", key), nil
}

func TestCacheClosing(env *testing.T) {
	updater := Updater{Called: make(map[string]int), WaitTime: time.Duration(1)}

	timer := time.NewTimer(time.Duration(1) * time.Second)

	done := make(chan interface{})

	go func() {
		defer close(done)
		s := NewCacheSession(updater.Update, 0, false, 4)
		s.Close()
	}()

	select {
	case <-timer.C:
		env.Errorf("cannot create-delete a CacheSession in a second")
	case <-done:
	}
}

func TestUpdaterCalledOnceWithGet(env *testing.T) {
	updater := Updater{Called: make(map[string]int), WaitTime: time.Duration(1)}

	s := NewCacheSession(updater.Update, 0, false, 10)

	wg := sync.WaitGroup{}

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(wid int) {
			defer wg.Done()
			key := fmt.Sprintf("key-%d", i)
			for i := 0; i < 10; i++ {
				s.Get(key)
			}
		}(i)
	}
	wg.Wait()

	for k, v := range updater.Called {
		if v != 1 {
			env.Errorf("Updating function for key %v called %d (should be 1)\n", k, v)
		}
	}
	s.Close()
}

func TestUpdaterCalledOnceWithPrepare(env *testing.T) {
	updater := Updater{Called: make(map[string]int), WaitTime: time.Duration(1)}

	s := NewCacheSession(updater.Update, 0, false, 10)

	wg := sync.WaitGroup{}

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(wid int) {
			defer wg.Done()
			key := fmt.Sprintf("key-%d", i)
			for i := 0; i < 10; i++ {
				s.Prepare(key)
			}
		}(i)
	}
	wg.Wait()

	wg = sync.WaitGroup{}
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(wid int) {
			defer wg.Done()
			key := fmt.Sprintf("key-%d", i)
			for i := 0; i < 10; i++ {
				if i%2 == 0 {
					s.Prepare(key)
				} else {
					s.Get(key)
				}
			}
		}(i)
	}
	wg.Wait()
	for k, v := range updater.Called {
		if v != 1 {
			env.Errorf("Updating function for key %v called %d (should be 1)\n", k, v)
		}
	}
	s.Close()
}

func TestWaitingQueue(env *testing.T) {
	updater := Updater{Called: make(map[string]int), WaitTime: time.Duration(2) * time.Second}

	s := NewCacheSession(updater.Update, 0, false, 10)

	wg := sync.WaitGroup{}
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(wid int) {
			defer wg.Done()
			s.Get("mykey")
		}(i)
	}
	wg.Wait()

	s.Close()
}

func TestRetriesOnError(env *testing.T) {
	updater := Updater{Called: make(map[string]int), WaitTime: time.Duration(1)}

	retries := 2
	s := NewCacheSession(updater.Update, retries, false, 10)

	val, err := s.Get("ERROR-1")

	if err == nil {
		env.Errorf("error did not generated,  val=[%v], err=[%v]", val, err)
	}

	if updater.Called["ERROR-1"] != retries+1 {
		env.Errorf("Cache did not retry right amount of time; tried(%v) != retried(%v) + 1", updater.Called["ERROR-1"], retries)
	}

	s.Close()
}

func TestErrorShouldNotCached(env *testing.T) {
	updater := Updater{Called: make(map[string]int), WaitTime: time.Duration(1)}

	retries := 1
	s := NewCacheSession(updater.Update, retries, false, 10)

	val, err := s.Get("ERROR-1")

	if err == nil {
		env.Errorf("error did not generated,  val=[%v], err=[%v]", val, err)
	}

	if s.Peek("ERROR-1") {
		env.Errorf("Cache entry for an error found.")
	}

	s.Close()
}

func TestErrorShouldCached(env *testing.T) {
	updater := Updater{Called: make(map[string]int), WaitTime: time.Duration(1)}

	retries := 1
	s := NewCacheSession(updater.Update, retries, true, 10)

	val, err := s.Get("ERROR-1")

	if err == nil {
		env.Errorf("error did not generated,  val=[%v], err=[%v]", val, err)
	}

	if !s.Peek("ERROR-1") {
		env.Errorf("Cache entry for an error not found.")
	}

	s.Close()
}
